#### 跟我一起写Makefile(陈皓)
#### 概述
一个工程的源文件不计其数，按功能、类型、模块分别放在若干目录下，makefile制定了整个工程的编译规则，哪些文件需要先编译，哪些后编译，哪些需要重新编译，甚至更复杂的功能操作。跟Shell一样可以执行操作系统命令。
makefile的优势就是**自动化编译**，只需一个make命令，整个工程自动编译，极大提高效率。
make是一个解释Makefile中指令的命令工具。
*编译和链接*
编译的过程，首先把源文件(.c/.cpp)**编译**成中间目标文件(.o)，然后把大量的.o文件合成执行文件（**链接**）。编译时，编译器检查程序语法，函数与变量是否声明，如果函数未被声明，编译器会给出警告，但可以生成中间目标文件。链接时，主要是链接函数和全局变量，链接器会在所有的.o文件中找寻函数的实现，找不到就报错误码。链接器并不管函数所在的源文件，只管函数的中间目标文件。大多数时候，源文件太多，生成的中间目标文件太多，链接时需要明显的指出中间目标文件，这对编译很不方便，所以，要给中间目标文件打个包，Unix下就是.a文件。

1. 介绍
make命令执行时，需要一个makefile文件告诉它怎样去编译和链接程序。
规则是：
1）如果这个工程没有编译过，那么所有的源文件都要编译并被链接。
2）如果这个工程的某几个文件被修改了，那么我们只编译被修改的源文件，并链接目标程序。
3）如果这个工程的头文件被修改了，那我们需要编译引用了这几个头文件的源文件，并链接目标程序。
只要写好makefile，一个make命令可以自动智能的根据当前的文件修改情况来确定哪些文件需要重新编译，从而自己编译所需要的文件和链接目标程序。

2. 规则
target ... : prerequisites ...
	command
	...
	...
target是一个目标文件，可以是中间目标文件，也可以是执行文件，还可以是标签(label)。
prequisites是要生成target所需的文件或目标。
command是make需要执行的命令(任意的shell命令)。
上述结构说明了文件的依赖关系，target依赖prerequisites中的文件，生成规则定义在command中。如果prerequisites中的文件比target要新的话就执行command中的命令。这是makefile的规则，也是最核心的内容。

3. 示例
4. make是如何工作的
默认方式下，只输入make命令：
1）make会在当前目录下找名字叫"Makefile"或"makefile"文件。
2）如果找到，它会找文件中的第一个目标文件(target)，并把这个文件作为最终的目标文件。
3）如果target文件不存在，或是它所依赖的.o文件的文件修改时间比target文件新，那么就会执行后面定义的命令生成target。
4）类似的对于.o文件，make会在当前文件中找目标为.o文件的依赖性，找到就根据其后的command生成.o文件（类似堆栈的过程）。
5）.c和.h文件肯定是存在的，于是make会生成.o文件，再用.o文件生成执行文件。
这便是make的依赖性，make会一层层去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻过程中如果出错，比如最后被依赖的文件找不到，make会直接退出并报错，而对于所定义的命令的错误或是编译不成功，make根本不理会。make只管文件的依赖性，即如果在找到了依赖关系后，冒号后的文件还是不存在，就停止工作。像clean没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行。需要显示的调用make clean执行清除所有目标文件。

5. makefile中使用变量
如果makefile中有些内容重复多次，比如.o文件在target后面重复两次，clean中重复一次，后期修改需要修改多个地方，为了方便可以使用变量赋值代替重复出现的内容，比如OBJ = ...，然后使用时就是$(OBJ)。

6. 让make自动推导
make可以自动推导文件以及文件依赖关系后面的命令，所以没必要每个.o文件后都写上类似的命令。因为make会自动识别，并自己推导命令。
只要看到一个.o文件，他会自动把.c文件加在依赖关系中，并且command中的cc -c .c会被推导出来。
.PHNOY : clean中的.PHONY表示clean是一个伪目标文件。

7. 另类风格的makefile
8. 清空目标文件的规则


#### Makefile总述
1. Makefile里有什么？
主要包含5个东西：显式规则、隐晦规则、变量定义、文件指示和注释
1）显式规则：如何生成一个或多个的目标文件，这是Makefile书写者明显指出的，要生成的文件，文件的依赖文件，生成的命令。
2）隐晦规则：make具有自动推导的功能，所以隐晦的规则可以让我们比较粗糙简略的写Makefile。
3）变量定义：定义的一系列变量（一般是字符串，类似宏），当Makefile被执行，其中的变量会扩展。
4）文件指示：包含三部分，一是在一个Makefile中引用另一个Makefile，就像include；另一个时根据某些情况指定Makefile中的有效部分，类似#if；还有是定义一个多行的命令。
5）注释：使用#。
Makefile中的命令，必须以[Tab]键开始。

2. Makefile的文件名
最好使用Makefile作为文件名，或者使用自定义名称，make时使用make -f(--file) filename。

3. 引用其他的Makefile
使用include关键字把别的Makefile包含进来。被包含的文件会原模原样的放在当前文件的包含位置。
语法：include <filename>
filename可以是当前操作系统Shell的文件模式(可以包含路径通配符)。
include前可以包含空格，但绝不能以[Tab]开始。
如果没有指定绝对路径或相对路径时，make会首先在当前目录查找，如果当前目录没有找到，make还会在以下目录查找：
1）如果make执行时，有"-I"或"--include-dir"参数，make就会在这个参数指定的目录下查找。
2）如果目录<prefix>/include(一般时/usr/local/bin或/usr/include)存在，make也会去找。

4. 环境变量MAKEFILES
环境中设置的变量MAKEFILES类似于include，不同的是，环境变量中定义出现错误，make会不理。
不建议使用，一旦定义，所有的Makefile都会收到这个变量影响。

5. make的工作方式
工作步骤：
第一阶段：
1）读入所有的Makefile
2）读入被include的其他Makefile
3）初始化文件中的变量
4）推导隐晦规则，并分析所有规则
5）为所有的目标文件创建依赖关系链
第二阶段：
6）根据依赖关系，决定哪些目标要重新生成
7）执行生成命令

#### 书写规则
规则包含两部分：依赖关系，生成目标的方法。
Makefile中规则的顺序很重要，因为Makefile中只应该有一个最终目标，其他目标都是被这个目标连带出来的，一般来说，定义在第一条规则中的将被确立为最终的目标，如果第一条规则中的目标有很多，第一个目标会成为最终目标。
1）在规则中使用通配符
make支持3个通配符："*"、"?"、"[...]"
2）文件搜寻
源文件存放在不同的目录下，make需要去查找文件的依赖关系时，可以在文件前加上路径，单最好的办法是把一个路径告诉make让它自动查找。
Makefile中特殊变量**VPATH**完成该工作，如果没有指明这个变量，make只会在当前目录下查找依赖文件和目标文件。如果定义了这个变量，那么make就在当前目录没找到的情况下到指定目录下去查找文件。
格式：VPATH src:/..header，按顺序查找文件（当前目录永远首先查找），目录用":"分隔。
另一个设置文件搜索路径的方法是使用关键字vpath。
3）伪目标
例如经常使用的例子：
clean:
	rm *.o temp
其中clean就是一个目标。既然我们生成了许多文件，应该提供一个清除它们的"目标"。
但是我们并不生成"clean"这个文件，**"伪目标"并不是一个文件，而是一个标签**。由于"伪目标"不是文件，make无法生成他的依赖关系和决定它是否执行。只有显式
的指明这个"目标"才能使其生效。为了避免和文件名重名，可以使用特殊标记".PHONY"显式指明一个目标是"伪目标"。
伪目标一般没有依赖的文件，但是我们可以为伪目标指定所依赖的文件。伪目标可以作为"默认目标"，只要将其放在第一个。例如，Makefile需要一口气生成多个可执行文件，但是只想写一个make命令，可以使用伪目标：
"""
all : prog1 prog2 prog3
    .PHONY : all
    prog1 : prog1.o utils.o
            cc -o prog1 prog1.o utils.o
    prog2 : prog2.o
            cc -o prog2 prog2.o
    prog3 : prog3.o sort.o utils.o
            cc -o prog3 prog3.o sort.o utils.o
"""
Makefile会将第一个目标作为默认目标。伪目标的特性是总是被执行的。同样的，伪目标也可以成为依赖：
"""
.PHONY: cleanall cleanobj cleandiff
cleanall : cleanobj cleandiff
            rm program
    cleanobj :
            rm *.o
    cleandiff :
            rm *.diff
"""
4）多目标
5）静态模式
 <targets ...>: <target-pattern>: <prereq-patterns ...>
            <commands>
			...

target-pattern：目标集模式
prereq-patterns：依赖模式，对target-pattern形成的模式再进行一次依赖目标的定义。
6）自动生成依赖性

#### 书写命令
