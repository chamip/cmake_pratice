#### 跟我一起写Makefile(陈皓)
#### 概述
一个工程的源文件不计其数，按功能、类型、模块分别放在若干目录下，makefile制定了整个工程的编译规则，哪些文件需要先编译，哪些后编译，哪些需要重新编译，甚至更复杂的功能操作。跟Shell一样可以执行操作系统命令。
makefile的优势就是**自动化编译**，只需一个make命令，整个工程自动编译，极大提高效率。
make是一个解释Makefile中指令的命令工具。
*编译和链接*
编译的过程，首先把源文件(.c/.cpp)**编译**成中间目标文件(.o)，然后把大量的.o文件合成执行文件（**链接**）。编译时，编译器检查程序语法，函数与变量是否声明，如果函数未被声明，编译器会给出警告，但可以生成中间目标文件。链接时，主要是链接函数和全局变量，链接器会在所有的.o文件中找寻函数的实现，找不到就报错误码。链接器并不管函数所在的源文件，只管函数的中间目标文件。大多数时候，源文件太多，生成的中间目标文件太多，链接时需要明显的指出中间目标文件，这对编译很不方便，所以，要给中间目标文件打个包，Unix下就是.a文件。

1. 介绍
make命令执行时，需要一个makefile文件告诉它怎样去编译和链接程序。
规则是：
1）如果这个工程没有编译过，那么所有的源文件都要编译并被链接。
2）如果这个工程的某几个文件被修改了，那么我们只编译被修改的源文件，并链接目标程序。
3）如果这个工程的头文件被修改了，那我们需要编译引用了这几个头文件的源文件，并链接目标程序。
只要写好makefile，一个make命令可以自动智能的根据当前的文件修改情况来确定哪些文件需要重新编译，从而自己编译所需要的文件和链接目标程序。

2. 规则
target ... : prerequisites ...
	command
	...
	...
target是一个目标文件，可以是中间目标文件，也可以是执行文件，还可以是标签(label)。
prequisites是要生成target所需的文件或目标。
command是make需要执行的命令(任意的shell命令)。
上述结构说明了文件的依赖关系，target依赖prerequisites中的文件，生成规则定义在command中。如果prerequisites中的文件比target要新的话就执行command中的命令。这是makefile的规则，也是最核心的内容。

3. 示例
4. make是如何工作的
默认方式下，只输入make命令：
1）make会在当前目录下找名字叫"Makefile"或"makefile"文件。
2）如果找到，它会找文件中的第一个目标文件(target)，并把这个文件作为最终的目标文件。
3）如果target文件不存在，或是它所依赖的.o文件的文件修改时间比target文件新，那么就会执行后面定义的命令生成target。
4）类似的对于.o文件，make会在当前文件中找目标为.o文件的依赖性，找到就根据其后的command生成.o文件（类似堆栈的过程）。
5）.c和.h文件肯定是存在的，于是make会生成.o文件，再用.o文件生成执行文件。
这便是make的依赖性，make会一层层去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻过程中如果出错，比如最后被依赖的文件找不到，make会直接退出并报错，而对于所定义的命令的错误或是编译不成功，make根本不理会。make只管文件的依赖性，即如果在找到了依赖关系后，冒号后的文件还是不存在，就停止工作。像clean没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行。需要显示的调用make clean执行清除所有目标文件。

5. makefile中使用变量
如果makefile中有些内容重复多次，比如.o文件在target后面重复两次，clean中重复一次，后期修改需要修改多个地方，为了方便可以使用变量赋值代替重复出现的内容，比如OBJ = ...，然后使用时就是$(OBJ)。

6. 让make自动推导
make可以自动推导文件以及文件依赖关系后面的命令，所以没必要每个.o文件后都写上类似的命令。因为make会自动识别，并自己推导命令。
只要看到一个.o文件，他会自动把.c文件加在依赖关系中，并且command中的cc -c .c会被推导出来。
.PHNOY : clean中的.PHONY表示clean是一个伪目标文件。

7. 另类风格的makefile
8. 清空目标文件的规则


#### Makefile总述
1. Makefile里有什么？
主要包含5个东西：显式规则、隐晦规则、变量定义、文件指示和注释
1）显式规则：如何生成一个或多个的目标文件，这是Makefile书写者明显指出的，要生成的文件，文件的依赖文件，生成的命令。
2）隐晦规则：make具有自动推导的功能，所以隐晦的规则可以让我们比较粗糙简略的写Makefile。
3）变量定义：定义的一系列变量（一般是字符串，类似宏），当Makefile被执行，其中的变量会扩展。
4）文件指示：包含三部分，一是在一个Makefile中引用另一个Makefile，就像include；另一个时根据某些情况指定Makefile中的有效部分，类似#if；还有是定义一个多行的命令。
5）注释：使用#。
Makefile中的命令，必须以[Tab]键开始。

2. Makefile的文件名
最好使用Makefile作为文件名，或者使用自定义名称，make时使用make -f(--file) filename。

3. 引用其他的Makefile
使用include关键字把别的Makefile包含进来。被包含的文件会原模原样的放在当前文件的包含位置。
语法：include <filename>
filename可以是当前操作系统Shell的文件模式(可以包含路径通配符)。
include前可以包含空格，但绝不能以[Tab]开始。
如果没有指定绝对路径或相对路径时，make会首先在当前目录查找，如果当前目录没有找到，make还会在以下目录查找：
1）如果make执行时，有"-I"或"--include-dir"参数，make就会在这个参数指定的目录下查找。
2）如果目录<prefix>/include(一般时/usr/local/bin或/usr/include)存在，make也会去找。

4. 环境变量MAKEFILES
环境中设置的变量MAKEFILES类似于include，不同的是，环境变量中定义出现错误，make会不理。
不建议使用，一旦定义，所有的Makefile都会收到这个变量影响。

5. make的工作方式
工作步骤：
第一阶段：
1）读入所有的Makefile
2）读入被include的其他Makefile
3）初始化文件中的变量
4）推导隐晦规则，并分析所有规则
5）为所有的目标文件创建依赖关系链
第二阶段：
6）根据依赖关系，决定哪些目标要重新生成
7）执行生成命令

#### 书写规则
规则包含两部分：依赖关系，生成目标的方法。
Makefile中规则的顺序很重要，因为Makefile中只应该有一个最终目标，其他目标都是被这个目标连带出来的，一般来说，定义在第一条规则中的将被确立为最终的目标，如果第一条规则中的目标有很多，第一个目标会成为最终目标。
1）在规则中使用通配符
make支持3个通配符："*"、"?"、"[...]"
2）文件搜寻
源文件存放在不同的目录下，make需要去查找文件的依赖关系时，可以在文件前加上路径，单最好的办法是把一个路径告诉make让它自动查找。
Makefile中特殊变量**VPATH**完成该工作，如果没有指明这个变量，make只会在当前目录下查找依赖文件和目标文件。如果定义了这个变量，那么make就在当前目录没找到的情况下到指定目录下去查找文件。
格式：VPATH src:/..header，按顺序查找文件（当前目录永远首先查找），目录用":"分隔。
另一个设置文件搜索路径的方法是使用关键字vpath。
3）伪目标
例如经常使用的例子：
clean:
	rm *.o temp
其中clean就是一个目标。既然我们生成了许多文件，应该提供一个清除它们的"目标"。
但是我们并不生成"clean"这个文件，**"伪目标"并不是一个文件，而是一个标签**。由于"伪目标"不是文件，make无法生成他的依赖关系和决定它是否执行。只有显式
的指明这个"目标"才能使其生效。为了避免和文件名重名，可以使用特殊标记".PHONY"显式指明一个目标是"伪目标"。
伪目标一般没有依赖的文件，但是我们可以为伪目标指定所依赖的文件。伪目标可以作为"默认目标"，只要将其放在第一个。例如，Makefile需要一口气生成多个可执行文件，但是只想写一个make命令，可以使用伪目标：
"""
all : prog1 prog2 prog3
    .PHONY : all
    prog1 : prog1.o utils.o
            cc -o prog1 prog1.o utils.o
    prog2 : prog2.o
            cc -o prog2 prog2.o
    prog3 : prog3.o sort.o utils.o
            cc -o prog3 prog3.o sort.o utils.o
"""
Makefile会将第一个目标作为默认目标。伪目标的特性是总是被执行的。同样的，伪目标也可以成为依赖：
"""
.PHONY: cleanall cleanobj cleandiff
cleanall : cleanobj cleandiff
            rm program
    cleanobj :
            rm *.o
    cleandiff :
            rm *.diff
"""
4）多目标
5）静态模式
 <targets ...>: <target-pattern>: <prereq-patterns ...>
            <commands>
			...

target-pattern：目标集模式
prereq-patterns：依赖模式，对target-pattern形成的模式再进行一次依赖目标的定义。
6）自动生成依赖性

#### 书写命令
make命令默认是被/bin/sh解释执行的。
1. 显示命令
命令前有"@"，命令将不被显示。
make带有参数"-n"或"--just-print"，显示命令但不执行；有利于我们调试Makefile，看看书写的命令执行起来是什么顺序。
make带有参数"-s"或"--slient"，则是全面禁止命令的显示。
2. 命令执行
如果想要第二条命令在第一条命令的基础上运行，使用分号分隔命令。
3. 命令出错
有时候命令出错并不是出现错误。在Makefile命令行前加上"-"标记为命令不管出不出错都认为是成功的。
还有一个全局办法是make加上"i"或是"--ignore-errors"参数，Makefile中所有的命令都会忽略错误。
4. 嵌套执行make
5. 定义命令包

#### 使用变量
Makefile中的定义的变量就像c++中的宏，代表一个文本字串，Makefile执行时自动原模原样展开在所使用的地方。不同的是，可以在Makefile中改变其值，变量可以使用在"目标"、"依赖目标"、"命令"或是Makefile的其他部分。
变量的命名字可以包含字符、数字，下划线(可以是数字开头)，但不应该含有“:”、“#”、“=”或是空字符 (空格、回车等)。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的 Makefile 的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如:MakeFlags。这样可以避免和系 统的变量冲突，而发生意外的事情。
1. 变量的基础
变量在声明时需要给予初值，而在使用时，需要给在变量名前加上"$"符号，但最好用小括号"()"或是大括号"{}"把变量给包括起来。如果你要使用真实的"$"字符，那么你需要用"$$"来表示。
2. 变量中的变量
先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在 文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。
为了避免上面的这种方法，我们可以使用 make 中的另一种用变量来定义变量的方法。这种方法使用的是 “:=”操作符，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量
3. 变量的高级用法
第一种是变量值的替换。我们可以替换变量中的共有的部分，其格式是“$(var:a=b)”或是“${var:a=b}”，其意思是，把变量“var” 中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。
第二种高级用法是——“把变量的值再当成变量”。
4. 追加变量值
我们可以使用“+=”操作符给变量追加值。如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作 的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符。
5. override指示符
如果变量是在make命令行参数中设置的，Makefile中对这个变量的赋值会被忽略。如果想在Makefile中设置，可以使用override。
override <variable> = <value>
override <variable> := <value>
追加：override <variable> += <more text>
6. 多行变量
7. 环境变量
8. 目标变量
9. 模式变量
模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义 在符合这种模式的所有目标上。
我们知道，make 的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量:
	%.o : CFLAGS = -O

#### 使用条件判断
让 make 根据运行时的不同情况选择不同的执行分支。
1. 示例
2. 语法
<conditional-directive>
    <text-if-true>
    endif
以及:
    <conditional-directive>
    <text-if-true>
    else
    <text-if-false>
endif
其中<conditional-directive>表示条件关键字：ifeq、ifneq、ifdef、ifndef。

ifdef 只是测试一个变量是否有值，其并不会把变量扩展到当前位 置。还是来看两个例子:
示例一:
    bar =
    foo = $(bar)
    ifdef foo
frobozz = yes
    else
    frobozz = no
    endif
示例二:
    foo =
    ifdef foo
    frobozz = yes
    else
    frobozz = no
    endif
第一个例子中，“$(frobozz)”值是“yes”，第二个则是“no”。

make是在读取 Makefile 时就计算条件表达式的值，并根据条件表达式的值来选择语句， 所以，你最好不要把自动化变量(如“$@”等)放入条件表达式中，因为自动化变量是在运行时才有的。

#### 使用函数
